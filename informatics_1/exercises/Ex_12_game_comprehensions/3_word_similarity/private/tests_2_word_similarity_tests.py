#!/usr/bin/env python3

from unittest import TestCase
from unittest.mock import mock_open, patch
import ast, types
import math

# catch potential exception from import
try:
    from public.script import WordLogic
except Exception:
    # Just make sure that all tests are still executed to have a stable number of points.
    # An appropriate warning is generated by the smoke tests.
    pass

filename = 'resource/words.txt'
with open(filename) as f:
    read_data = f.read()
    word_list = [word.rstrip().upper() for word in read_data.split('\n')]

class PrivateInformationHidingTestSuite(TestCase):

    @patch('builtins.open', new_callable=mock_open, read_data=read_data)
    def test_word_selection(self, mock_open):
        # Without this try/except block this test fails with an error on the unchanged task, but the student still gets a point.
        try:
            WordLogic.is_similar
        except AttributeError:
            m = "@@The WordLogic class does not appear to have an is_similar method. You need to implement it.@@"
            self.fail(m)
        num_words = 30
        sut = WordLogic(num_words, 8)

        def compute_distribution():
            words_chosen_at_random = sut.word_selection()

            self.assertTrue(len(set(words_chosen_at_random)) == len(words_chosen_at_random),
                            "@@There appear to be duplicates in the word list@@")

            word_distributions = {'random_third': [], 'remaining_similar': []}

            for word in words_chosen_at_random:

                self.assertEqual(len(word), sut.len_words, "@@The length of the words appears to be wrong@@")

                other_similar_word = next(
                    (x for x in words_chosen_at_random if word != x and sut.is_similar(word, x, 0.4)), None)

                if other_similar_word:
                    word_distributions['remaining_similar'].append(word)
                else:
                    word_distributions['random_third'].append(word)

            total_words_count = len(words_chosen_at_random)
            number_of_words_with_no_similars = len(word_distributions['random_third'])
            number_of_words_with_similars = len(word_distributions['remaining_similar'])

            self.assertGreaterEqual(number_of_words_with_similars,
                                    math.floor((total_words_count - total_words_count) / 2),
                                    '@@The proportion of similar words to random words is less than 2/3.@@')
            self.assertLessEqual(number_of_words_with_no_similars, math.ceil(total_words_count / 2),
                                 '@@The proportion of random words to similar words is more than 1/3.@@')

        number_of_runs = 3
        for i in range(number_of_runs):
            compute_distribution()


class SolutionVisitor(ast.NodeVisitor):

    def __init__(self):
        self.hasAssignInGlobalScope = False

    def visit_If(self, node):
        try:
            if node.test.left.id == "__name__":
                return
        except:
            self.generic_visit(node)

    def visit_Assign(self, node):
        self.hasAssignInGlobalScope = True

    def visit_FunctionDef(self, node):
        return

    def visit_ClassDef(self, node):
        return

